# Large Graph Layout - LGL 

[![Build Status](https://teamcity.eskaduren.se/app/rest/builds/buildType:(id:Phdeis_BasicRunLgl)/statusIcon.svg)](https://teamcity.eskaduren.se) ![Github build all](https://github.com/flindeberg/LGL/workflows/Build%20and%20install%20CI/badge.svg) ![Github test all](https://github.com/flindeberg/LGL/workflows/Testrun%20CI/badge.svg)


All files distributed with LGL fall under the terms of 
the GNU General Public License, and are copyright (c) 2002, 2003 Alex Adai.

Changes and updates copyright (c) 2004-2021 Barrett Lyon

Addtional changes done in this fork copyright (c) 2019, 2020 Fredrik Lindeberg

LGL on the web at:  http://www.opte.org/lgl/ 

Much thanks to the Marcotte lab for testing. 

If you use this in your research, please cite (if possible):
- Lyon, Barrett. "The Opte Project." Mapping the Internet, Self, 2004. http://www.opte.org.
- Adai, Alex T., Shailesh V. Date, Shannon Wieland, and Edward M. Marcotte. “LGL: Creating a Map of Protein Function with an Algorithm for Visualizing Very Large Biological Networks.” Journal of Molecular Biology 340, no. 1 (2004): 179–90. https://doi.org/10.1016/j.jmb.2004.04.047.
- Lindeberg, Fredrik. “Coordinating the Internet.” Licentiate Thesis, Linköping University, 2019. http://urn.kb.se/resolve?urn=urn:nbn:se:liu:diva-161812.


# Example output

![The Internet 2003](http://videobot.ash1.opte.org/content/opte/maps/static/1069646562.LGL.2D.4000x4000.png)

Example of the Internet using traceroute vs BGP in 2003. 


![Image of the Internet](https://raw.githubusercontent.com/flindeberg/LGL/master/resources/images/internet_2016.png)

An example of the Internet as generated by data from 2016. The grapher can in theory handle any kind of data in ncol-format.

# Requirements

A heap of stuff, in no particular order:

- A C++ compiler
- - Boost library required (I should have fixed version issues, but I have not future proofed it)
- bgpdump (https://bitbucket.org/ripencc/bgpdump/wiki/Home)
- - Seems broken in Debian distros, so compile from source if needed
- perl (5+, I think)
- Java (8 seems to work)
- Xserver installed for graphical tools (works well under WSL 2 in Windows)
- Python 3 (there are bash scripts lying around as well, but the python scripts are 3x faster)

# Installation

Use the Makefil, i.e.

    prompt$ make 
    prompt$ make install # local install in $(PROJECTDIR)/bin

should do the trick in the root directory (feel free to improve the magic
`setup.pl -i` script which does a lot of suspect lifting).

# Making Internet graphs

If your intention is to graph custom stuff, just hack away. Below is how you quite easily
can make graphs from bgp-dumps. You need a separate folder for each project, due to design
in the original LGL library. Below follows an example for a graph for a 2000 Internet. Takes 
around 10 minutes on a fairly modern computer (8 threads or so) with a decent Internet connection. 

The oneliner which creates a graph, including bootstrapping, from 2000-09-01:
    
    prompt$ cd scripts/
    prompt$ ./creategraphfromdate.sh 2000 09
    prompt$ # doing magic, and creating a graph
    prompt$ # arguments to creategraphfromdate are year and month
    prompt$ # and the scipt lacks proper error handling

The same thing but step by step (if above fails):

    prompt$ cd scripts/
    prompt$ ./create_run.sh internet_2000
    prompt$ cd ../testrun/internet_2000
    prompt$ wget http://data.ris.ripe.net/rrc00/2000.09/bview.20000901.0610.gz
    prompt$ ./bootstrap.sh bview.20000901.0610.gz
    prompt$ # doing magic, and creating a graph
    prompt$ # by default generating a 2400x2400 png (change run.sh for different resolution)
    prompt$ # should be a 'internet_2001.png' in 'testrun/internet_2001' if all went well
    
 Also possible:
 
    prompt$ cd scripts/
    prompt$ ./creategraphfromurl.sh http://data.ris.ripe.net/rrc00/2000.09/bview.20000901.0610.gz
    prompt$ # wait for magic, by default generating a 2400x2400 png (change run.sh for different resolution)
    prompt$ # should be a 'view.20000901.0610.png' in 'testrun/bview.20000901.0610' if all went well
 
Replace the bview-file with a more recent one for a larger and newer network network. Coloring is
set in `perls/colorEdgesBasedOnLevel.pl`, currently a mix of greenish and bluish tints going on white
at the edges. 

A short disclaimer; the graph is only as good as your data. The `bootstrap` script works for generating interesting graphs. Are they 100% correct? I don't know, you are welcome to check and improve the code! There might be BGP-quirks I do not know of, even though I catch the vast majority of bgp announcements. 

# Additional reading

User guide to LGL, helped me figure out some important things:
http://clairemcwhite.github.io/lgl-guide/

Getting up to speed on Internet routing:
http://networkingbodges.blogspot.com/2019/04/a-real-full-internet-table-in-lab.html
https://www.noction.com/blog/as-path-and-as-path-prepending

# Helpful Hints From Past README
## Table of contents

  0 Before compiling!
  I Setup and Installation
 II Other files that come with LGL
III Expanding LGL
IV  What's new for 2.0

## Before compiling!

Firstly, LGL will probably only compile with the GNU compilers. It was tested 
on FreeBSD 9.x and CentOS, but it should compile OK on other Linux 
distributions. For other operating systems you are on your own. Good Luck :-)

You must have the following Perl modules in your @INC path to run LGL:

ParseConfigFile.pm
LGLFormatHandler.pm

These files are in the ./perls directory.  You don't have to know anything 
about these modules, and you won't have to use them directly but lgl.pl will 
call them.

## Setup and installation

To compile LGL change to the same directory as setup.pl and type:

    prompt$ ./setup.pl -i

This will compile 2D and 3D versions of LGL and put the resulting binaries 
in the ./bin directory. Afterwards you can move them whereever you want.


NOTE:  setup.pl has been updated to locate boost, however you may need
       to direct gcc on where to find the includes if the automated 
       detection does not work:

       env CPLUS_INCLUDE_PATH=/usr/local/include ./setup.pl -i

After all is compiled and done you can run LGL by the driver script lgl.pl as:

    prompt$ ./bin/lgl.pl edges_file

but you have to modify the 'tmpdir' variable in lgl.pl. That directory will 
hold all the files that LGL outputs, and it must be changed for EACH run.  
However, The best way to run LGL is to have setup.pl generate a sample 
config file for lgl.pl by running it as

    prompt$ ./setup.pl -c conf_file_name

That file (after modification of course) can just be given to lgl.pl for 
execution as follows:

    prompt$ ./bin/lgl.pl -c conf_file_name

The config file itself is documented further, and explains each of the 
variables to be used.  It also provides defaults, so the minimum that MUST 
be changed are the variables:

    tmpdir
    inputfile

where tmpdir is the output directory of the LGL run and inputfile is the edge 
file. inputfile must be a file parsable by LGLFormatHandler.pm This can be 
just a simple 2 column space delimited file with one edge per line 
(the 2 vertex ids represent the two columns).

One last change is to ./bin/lgl.pl. A Perl variable $LGLDIR must be set to 
the root bin directory of all the lgl executables (This might be 
/where/lgl/was/unpacked/bin ). This var is empty by default, and the 
program won't run until it is set correctly.


## Further Reading
The software is designed to draw arbitrarily large trees/graphs, so the underlying algorithm has no functions for minimizing edge overlaps or other features specific for trees. Although functions exist for such things, LGL doesn’t have an implementation because the layouts would then not have such scalability. However, there are some tricks for doing layouts with trees.

First you need to do the following:
Make sure your tree is in a singly connected set. That is, every node is reachable by every other node in the graph by traversing edges. If it isn’t, your layouts will be awkward or undefined.

Make sure your tree is in .lgl format. You have to use the base programs so >only .lgl format will do, and not .ncol or any other format.

Now you can use lglayout2D directly (or lglayout3D) in the “bin” directory of the archive you downloaded and compiled. lglayout2D (or lglayout3D) is designed specifically for layouts of singly connected sets. Running it without arguments gives the argument list. A good option to toy with is -q. This gives the suggested edge distances.  For trees you might want to run it as:

prompt$ lglayout2D -q.05 sample.lgl. # Check your path to lglayout2D

What the -q option does is set the equilibrium distance of the edges. The smaller the q value; the more it draws the nodes closer together so the edge lengths aren’t as long. You can experiment with that side of it. Things that help are coloring the edges based on hierarchy – giving light edge colors to the higher order edges and darker colors for the lower order edges. That is what was done in the gallery file of SCOP. If you run a layout without adjusting the -q option, you may see what I call the hairdryer effect. That happens when all of the edges, in particular those to leaf nodes, are piled on top of each other in layouts.

Another option is to dive into the code; specifically the function placementFormula in calcFuncs.C. That function determines the placement distances for successive layers in the tree. If you feel your tree is getting too compressed, then changing the return value for that function to a much higher number will give the layout “more room”. Undoubtedly, this is probably the least desirable method; not to mention a total hack job, but I have had to do it for certain layouts.

However, for trees with perfectly non-overlapping edges, such as those drawn with phylogenetic programs, you may have to use other programs that are made to view such trees. Those specialized programs will provide clearer layouts. LGL is meant to be generic and can’t provide clearer layouts than software specialized for such layouts.  Another example is visualizing metabolic pathways – there you also have to minimize the edge overlaps and present the layout in a more symmetric manner with specific labels. The obvious drawback of such specialized programs is usually scalability.

 
## Runtime Options
-r (neighborhood radius) : Determines the size of a voxel, and looks to be related to the “breathing space” for each particle, so I think the larger this value the farther from each other will the particles be.  Default: 1.0

-R (outer radius) : Limits the area from which random points will be selected for placing the particles. So I think the larger this value the more area the image will take.  Default -1.0 (A negative value means this value would be calculated from the count of nodes. In case of 2 dimensions, that will be the square root of the count of nodes.)

-S (node size radius) : Ignore for now (researching more) Default 10.0

-q (equilibrium distance) : Specifies the distance between particles at which point they are considered too close. Quite likely to be useful. Default 0.5

-k (casual spring constant), -s (special spring constant) : This look to affect the “force” of repulsion between the particles. The larger the value(s?), the stronger that force will be (the farther the particles will end up from each other). Deafult 10.0

-u (placement distance), -v (placement radius) : Ignore for now researching

 

## Viewing Results

Two files are necessary for looking at the results of your layout. The first is the edge file and the second is the coordinates. While these files are the minimum, other types of input are allowable for highlighting your 2D or 3D layout.  Such additions can include coloring the edges, vertices, labeling, and more.

2D
lglview
LGLLib.jar is a JAVA application written solely for viewing 2D graphs generated by LGL, although it can view graphs generated by other means if 2D coordinates are available, such as parsing ‘line to’ calls in existing .ps graph files.

Include binaries are compiled with Java 1.6 which contains both Viewer2D and ImageMaker.

LGLLib / ImageViewer

Full viewing library with 2D viewer and image output.  Runtime example:

java -Xmx512m -Xms256m -cp ./LGLLib.jar Viewer2D.Viewer2D


ImageMaker (PNG output)

java -Xmx512m -Xms256m -cp ./LGLLib.jar ImageMaker.GenerateImages <params>

 

## Legacy Support

If you prefer or have shell scripts which already uses the previous jars names we have also attaching also ImageMaker.jar and LGLView.jar to support legacy configurations:

java -Xmx512m -Xms256m -jar ./LGLView.jar

java -Xmx512m -Xms256m -jar ./ImageMaker.jar

Please understand that lglview is pretty primitive, and should be considered a work in progress.

Note: -Xmx and -Xms is key to provide enough memory to the JRE.

## 3D
For viewing 3D graphs, a PERL script, genVrml.pl, is available to generate a VRML file, which is viewable with a VRML browser. The perl script has options for edge and vertex coloring, URL anchoring, text labels, and more.  genVrml.pl uses the VRML module, which is freely available from CPAN. It also requires an internally develped (and not yet documented) module LGLFormatHandler.pm. These are necessary to compile and run the PERL script, so they must be in your PERL @INC path. You don’t have to use or call these modules directly, but the script will.  This script does not generate optimal VRML code, but necessity or interest (or outside advice) could elicit a revision.

For usage of genVrml.pl, just run the script without any arguments and read the output. The command genVrml.pl edges.lgl layout.coords (where edges.lgl is your edge file and layout.coords is a 3D layout) will get some VRML code going and get you started. The output VRML file is always the coords file + ‘.wrl’. So in the short example above, the output file would be layout.coords.wrl.

Large Image Output
We are attempting to write a version that can output a huge PNG (100k x 100k pixels).  Currently there is a limitation on java.awt.image.Raster: The maximum width x height has to be less than Integer.MAX_VALUE (2147483647) so the maximum square image is 46340 x 46340. Note also that such images will need a lot of RAM since Java’s BufferedImage’s pixels are hold in memory.

Example for utilizing more memory for larger images:

java  -Xms1G -Xmx5G -jar ImageMaker.jar 29200 29200 <files…>

It seems that generating a 46340 x 46340 image will require something like 30G of RAM.

 

 

## File Formats

There are several files involved in creating a graph:  .lgl, .coords, .colors

The .lgl Format
There are two different file formats that used for the edge files, which are denoted with the file suffixes .lgl (LGL format) and the .ncol format. The .ncol edge files are simple two column files, where two vertices are on each line of the file white space delimited:

vertex2name [optionalWeight]
vertex1name vertex3name [optionalWeight]
...
The graphs here are undirected, and LGL is pretty particular about that. So if you have an edge A <-> B, then you should not have an edge B <-> A. As far as the .ncol file is concerned, you should NOT have:

vertex1name vertex2name
vertex2name vertex1name
in the same file, nor should any vertex have an edge to itself.

The second format is the LGL file format (.lgl file suffix). This is yet another graph file format that tries to be as stingy as possible with space, yet keeping the edge file in a human readable (not binary) format.  The format itself is like the following:

# vertex1name
vertex2name [optionalWeight]
vertex3name [optionalWeight]
Here, the first vertex of an edge is preceded with a pound sign ‘#’. Then each vertex that shares an edge with that vertex is listed one per line on subsequent lines. Again, you can’t have directed edges in the file so you should NOT have:

# vertex1name
vertex2name
# vertex2name
vertex1name
in the same file.

The .colors Format
The color formatting for input to ImageViewer or ImageMaker is rather tricky:

vertex1 vertex2 R G B

Example:

20067 20067.1 0.172549019608 0.239215686275 0.866666666667
2631 2631.1 0 0.0078431372549 0.411764705882
8119 8119.1 0 0.0078431372549 0.411764705882
To convert RGB, take the single color and divide it by 255.

 


## Other files that come with LGL

A list of important files in the perls dir:

    genVrml.pl - This generates the VRML code from 3D layout results. Run 
    genVrml.pl with no args to get the usage.

colorEdgesBasedOnLevel.pl - This generates a simple color file to be 
given to lglview, that will color your edges based on the level in the 
heirarchy in layout.

Other files might be included as well, but they are not necessary for LGL. 
Their documentation will be added here in the near future, or they may not 
be carried in the future.

### Other Files:


LGLView.jar - A JAVA 2D viewer for looking at the output of lgl.pl. The output of the layout programs is just a set of coordinates.  For looking at 2D 
coordinates use lglview.jar See the web page http://www.opte.org/lgl for 
usage and other info.

ImageMaker.jar - A JAVA 2D image output tool.  For more detail visit http://www.opte.org/lgl/

Looking at the huge PNG (100k x 100k pixels) java.awt.image.Raster: The 
maximum width x height has to be less than Integer.MAX_VALUE (2147483647) so 
the maximum square image is 46340 x 46340. Note also that such images will 
need a lot of RAM since Java's BufferedImage's pixels are hold in memory. 

An example of a larger output would be: 

    java  -Xms1G -Xmx5G -jar ImageMaker.jar 29200 29200 <files...>

    LGLView.jar - The full package that combines LGLView and ImageMaker.

    Java - Directory and source code of all JAVA programs.  See README in the JAVA dir.


## Expanding LGL

The most obvious way to expand LGL is to add support for your type of edge file to LGLFormatHandler.pm.  Just add a method to read in your file type, update 
the 'loadFromFile' method to recognize your file suffix, and that should be it.

Let me know of any source code contributions that would make LGL more suitable 
and usable so I can add the code in!




